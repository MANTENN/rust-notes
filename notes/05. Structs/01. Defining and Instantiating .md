# Defining and Instantiating Structs

can contain different named--unlike tuples--types

## Defining

to define use `struct` seperated with a space followed by a name, and `{` and `}`. Inside the struct's body, declare *fields* using `key: value` pairs;
ex:

``` rust
struct User {
    username: String,
    email: String,
    active: bool,
}
```

## Creating an Instance

use the structs name followed by `{}`, inside the `{}` define each field's value.

ex:

``` rust
let user1 = User {
    username: "Nazar",
    email: "nazar@gmail.com",
    active: true,s
}
```

to grab a value use the dot notation; to grab an email, from the user object it would be: `user1.email`

if the instance is mutable, values can be changed using the dot notation

can implicitly return the newly constructed instance like any expression

map parameters to structs keys

### Field Init Shorthand

- variables and field names need to have the same name
- omit value like in JavaScript when assigning variable names as properties

ex

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

### Creating Instances From Other Instances With Struct Update Syntax

*Struct Update Syntax* grabs non specified values from the specified struct instance

Create with values from other instances without *update syntax*
```rust
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
```

> The syntax `..` specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.

ex

```rust
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```

### Using Tuple Structs without Named Fields to Create Different Types

> You can also define structs that look similar to tuples, called tuple structs. Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type than other tuples, and naming each field as in a regular struct would be verbose or redundant.
>
> To define a tuple struct, start with the struct keyword and the struct name followed by the types in the tuple.

ex

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

> Each struct you define is its own type, even though the fields within the struct have the same types.
> Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a . followed by the index to access an individual value, and so on.

### Unit-Like Structs

structs without fields
behave similarly to `()`--the unit type

useful when

> you need to implement a trait on some type but don’t have any data that you want to store in the type itself.

ex `struct Food();`

## Ownership

> Using `String` ensures the struct owns all of its data, and it'll be valid as long as the struct is valid.
> It’s possible for structs to store references to data owned by something else, but to do so requires the use of *lifetimes*
>
> Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is.